var o={};const t=2147483647;const n=36;const e=1;const r=26;const c=38;const s=700;const i=72;const l=128;const u="-";const f=/^xn--/;const a=/[^\0-\x7E]/;const d=/[\x2E\u3002\uFF0E\uFF61]/g;const h={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"};const p=n-e;const g=Math.floor;const w=String.fromCharCode;function error(o){throw new RangeError(h[o])}function map(o,t){const n=[];let e=o.length;while(e--)n[e]=t(o[e]);return n}function mapDomain(o,t){const n=o.split("@");let e="";if(n.length>1){e=n[0]+"@";o=n[1];}o=o.replace(d,".");const r=o.split(".");const c=map(r,t).join(".");return e+c}function ucs2decode(o){const t=[];let n=0;const e=o.length;while(n<e){const r=o.charCodeAt(n++);if(r>=55296&&r<=56319&&n<e){const e=o.charCodeAt(n++);if(56320==(64512&e))t.push(((1023&r)<<10)+(1023&e)+65536);else {t.push(r);n--;}}else t.push(r);}return t}const ucs2encode=o=>String.fromCodePoint(...o);const basicToDigit=function(o){return o-48<10?o-22:o-65<26?o-65:o-97<26?o-97:n};const digitToBasic=function(o,t){return o+22+75*(o<26)-((0!=t)<<5)};const adapt=function(o,t,e){let i=0;o=e?g(o/s):o>>1;o+=g(o/t);for(;o>p*r>>1;i+=n)o=g(o/p);return g(i+(p+1)*o/(o+c))};const decode=function(o){const c=[];const s=o.length;let f=0;let a=l;let d=i;let h=o.lastIndexOf(u);h<0&&(h=0);for(let t=0;t<h;++t){o.charCodeAt(t)>=128&&error("not-basic");c.push(o.charCodeAt(t));}for(let i=h>0?h+1:0;i<s;){let l=f;for(let c=1,l=n;;l+=n){i>=s&&error("invalid-input");const u=basicToDigit(o.charCodeAt(i++));(u>=n||u>g((t-f)/c))&&error("overflow");f+=u*c;const a=l<=d?e:l>=d+r?r:l-d;if(u<a)break;const h=n-a;c>g(t/h)&&error("overflow");c*=h;}const u=c.length+1;d=adapt(f-l,u,0==l);g(f/u)>t-a&&error("overflow");a+=g(f/u);f%=u;c.splice(f++,0,a);}return String.fromCodePoint(...c)};const encode=function(o){const c=[];o=ucs2decode(o);let s=o.length;let f=l;let a=0;let d=i;for(const t of o)t<128&&c.push(w(t));let h=c.length;let p=h;h&&c.push(u);while(p<s){let s=t;for(const t of o)t>=f&&t<s&&(s=t);const i=p+1;s-f>g((t-a)/i)&&error("overflow");a+=(s-f)*i;f=s;for(const s of o){s<f&&++a>t&&error("overflow");if(s==f){let o=a;for(let t=n;;t+=n){const s=t<=d?e:t>=d+r?r:t-d;if(o<s)break;const i=o-s;const l=n-s;c.push(w(digitToBasic(s+i%l,0)));o=g(i/l);}c.push(w(digitToBasic(o,0)));d=adapt(a,i,p==h);a=0;++p;}}++a;++f;}return c.join("")};const toUnicode=function(o){return mapDomain(o,(function(o){return f.test(o)?decode(o.slice(4).toLowerCase()):o}))};const toASCII=function(o){return mapDomain(o,(function(o){return a.test(o)?"xn--"+encode(o):o}))};const v={version:"2.1.0",ucs2:{decode:ucs2decode,encode:ucs2encode},decode:decode,encode:encode,toASCII:toASCII,toUnicode:toUnicode};o=v;var m=o;

var decode$1 = m.decode;
var encode$1 = m.encode;
var toASCII$1 = m.toASCII;
var toUnicode$1 = m.toUnicode;
var ucs2 = m.ucs2;
var version = m.version;

export default m;
export { decode$1 as decode, encode$1 as encode, toASCII$1 as toASCII, toUnicode$1 as toUnicode, ucs2, version };
